#pragma kernel Test_Main

// 1. Resources.
#include "DanbiMathUtils.cginc"  
#include "DanbiGlobalRsrc.cginc"
#include "DanbiMeshData.cginc"
#include "DanbiCameraData.cginc"

#ifdef MATH_UTILS_INC
#ifdef GLOBAL_RSRC_INC 
#ifdef MESH_DATA_INC 
#ifdef CAMERA_DATA_INC

// 2. Kernal declarations.
#if USE_HEMISPHERE
  #include "Assets/Shaders/DanbiRenewed/DanbiHemisphere.cginc"
#elif USE_CONE
  #include "Assets/Shaders/DanbiRenewed/DanbiCone.cginc"
#elif USE_PARABOLOID
  #include "Assets/Shaders/DanbiRenewed/DanbiParaboloid.cginc"
#endif

// 2. Check the usage
#if FOR_CREATE_IMAGE
  // #include "Assets/Shaders/DanbiRenewed/DanbiCreateImage"
#elif FOR_PROJECTING
  // #include "Assets/Shaders/DanbiRenewed/DanbiProjecting"
#elif FOR_VIEW_AT_RUNTIME
  // #include "Assets/Shaders/DanbiRenewed/DanbiViewAtRuntime"
#endif

#if UNDISTORT_NEWTON
  #include "Assets/Shaders/DanbiRenewed/DanbiUndistortNewton.cginc"
#elif UNDISTORT_ITERATIVE
  #include "Assets/Shaders/DanbiRenewed/DanbiUndistortIterative.cginc"
#elif UNDISTORT_DIRECT
  #include "Assets/Shaders/DanbiRenewed/DanbiUndistortDirect.cginc"
#elif NO_UNDISTORT
//
#endif

#if DBG_ON
  #include "Assets/Shaders/DnabiRenewed/DanbiDbg.cginc"
#elif DBG_OFF
  // Nothing to do.
#endif

#endif
// 3. Mains.

[numthreads(8, 8, 1)]
void Test_Main(uint3 id : SV_DispatchThreadID) {
  float res = sdot(float3(1, 0, 0), float3(0, 1, 0), 2);
}


// 
// A basic structure with modules
//

/*
    - 1 Kernal per 1 file.
    - Resources must be inside 1 file.
    - RayTracing Prerequisites <-> RayTracing Kernals.
    - Math Utilities.

    1. Resoures which are required for calibrating the camera distortion on projecting at runtime.

    struct CameraParams { ... };
    StructuredBuffer<CameraParams> _CameraParams;

    2. MeshObjects informations which are required for updating the ray-tracing scene data.

    .. Cone
    .. HalfSphere
    .. UFOHalfSphere
    .. Panorama (Cylinder)
    .. Panorama (Cube)

    + Basically All the mesh objects are provided with Space Transformation
    since ComputeShader doesn't have embedded functions and field.

    3. 1 Big POD-style Geometry to calculate ray-tracing and to draw all meshes in a frame.

    struct POD_MeshData {
      public List<Vector3> vertices;
      public List<int> indices;
      public List<Vector2> texcoords;
      public List<int> indices_offsets;
      public List<int> indices_counts;
      public List<Matrix4x4> local2Worlds;
      public List<Vector3> albedos;
      public List<Vector3> speculars;
      public List<Vector3> emissions;
      public List<float> smoothnesses;
    };

    4. Dbg part as an utility module

    5. Global Resources that helps to perform the shader.

    .. mostly they are matrices.
    .. camera properties.

*/